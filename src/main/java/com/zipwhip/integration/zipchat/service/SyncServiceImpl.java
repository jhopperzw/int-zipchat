package com.zipwhip.integration.zipchat.service;

import com.zipwhip.integration.bi.domain.Stats;
import com.zipwhip.integration.bi.domain.StatsMetadataBuilder;
import com.zipwhip.integration.bi.service.StatsSenderService;
import com.zipwhip.integration.zipchat.entities.OrgConfig;
import com.zipwhip.message.domain.InboundMessage;
import com.zipwhip.message.utils.MessageUtils;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

/**
 * This class is used to perform sync functionality agnostic of the input source. If can be used to
 * sync a message to ZipChat (which will sync the contact to Zipwhip) or it can be used to Sync a
 * contact into ZipChat
 */
@Slf4j
@Service
public class SyncServiceImpl implements SyncService {

  /**
   * The service to use for logging usage statistics
   */
  @Autowired
  private StatsSenderService statsSenderService;

  /**
   * The ID of the ZipChat integration
   */
  @Value("${poller.integrationId}")
  private long integrationId;

  /**
   * Processes a message sent or received by an integrated landline. This will first find potential
   * contacts by mobile phone. Then it will sync (new and or update) contacts into Zipwhip. Finally,
   * it will attach the message to the appropriate claims in ZipChat.
   *
   * @param message   The message that was sent/received by the landline
   * @param orgConfig The orgConfig for the orgCustomer to which the landline belongs
   */
  @Override
  public void processMessage(InboundMessage message, OrgConfig orgConfig) {
    if (!orgConfig.getContactSyncFromCrmEnabled() && !orgConfig.getMessageArchiveToCrmEnabled()) {
      log.info("Contact Sync and Message Archive feature is disabled by user for org: {}",
        orgConfig.getOrgCustomerId());
      return;
    }

    final String mobile = MessageUtils.getPhone(message);
    final String landlineE164 = MessageUtils.formatE164(MessageUtils.getLandline(message));
    log.info("Find claim-contacts by phone: {}", mobile);
    List<ZipwhipClaimContact> claimContacts = accService.findByPhone(mobile, orgConfig);

    // if there are no claim-contacts associated with this number, then there is nothing to archive or sync
    if (claimContacts == null || claimContacts.isEmpty()) {
      log.info("No matching clients found for mobile: {}", mobile);
      return;
    }

    final String body = message.getPayload().getBody();
    log.info("Sync msg to {} potential targets for landline: {}, {}", claimContacts.size(),
      landlineE164, body);

    final SyncTargets syncTargets = extractSyncTargets(claimContacts, landlineE164,
      MessageUtils.formatE164(mobile));

    // Sync contacts first since it's an update and impact of double syncing is less
    log.info("Updating based on {} contact sync candidates with number {} matching landline {}",
      syncTargets.getContactSyncCandidates().size(), mobile,
      landlineE164);
    // If there are 1 or more contacts whose adjuster’s number matches the Zipwhip’s landline number on which the message was sent or received,
    // we update Zipwhip’s contact details with the record in the result set with the most recent ClaimLossDate.
    if (orgConfig.getContactSyncFromCrmEnabled()) {
      syncContactToZipwhip(message, syncTargets.getContactSyncCandidates(), orgConfig);
    } else {
      log.info("Contact Sync feature is disabled by user");
    }

    if (orgConfig.getMessageArchiveToCrmEnabled()) {
      // Sync messages after contact sync is complete
      composeConversations(message, syncTargets.getMessageSyncTargets(), orgConfig, mobile,
        landlineE164);
    } else {
      log.info("Message Archive feature is disabled by user");
    }
  }

  /**
   * @param label            The feature which is logging activity
   * @param message          The message that was synced
   * @param orgConfig        The orgConfig of the org customer for whom the sync was performed
   * @param messagePublicIds The list of message publicIDs which were generated by the sync
   */
  private void logMessageSyncStats(String label, InboundMessage message, OrgConfig orgConfig,
    List<String> messagePublicIds) {
    StatsMetadataBuilder metaDataBuilder = StatsMetadataBuilder.instance()
      .add("Landline", MessageUtils.getLandline(message));

    Stats stats = Stats.getInstance(integrationId, orgConfig.getOrgCustomerId())
      .addItem(label, (messagePublicIds != null ? messagePublicIds.size() : 0), metaDataBuilder);

    statsSenderService.send(stats);
  }
}
